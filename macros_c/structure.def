subcode:: parsecode_func_other
    $elif $func eq "tuple"
        declare_tuple($param)
        return
    $elif $func eq "tuple_name"
        get_T_name($param)
        return
    $elif $func eq "union"
        declare_union_anon($param)
        return

subcode:: parsecode_func_param_other
    $elif $func eq "struct"
        declare_struct($param1, $param2)
        return
    $elif $func eq "union"
        declare_union($param1, $param2)
        return


#-----------------------------------------
fncode: get_T_name($param)
    $global %tuple_hash
    my $name
    $if $tuple_hash{$param}
        $name = $tuple_hash{$param}
    $else
        $name=MyDef::utils::uniq_name("T", \%structs)
        $tuple_hash{$param}=$name

    MyDef::compileutil::set_current_macro("T", $name)
    return $name

#-----------------------------------------
#-- $tuple declares anonymous struct with a1, a2, ...
#--   ref: deflib/c/darray.def
fncode: declare_tuple($param) 
    my $name=get_T_name($param)

    my $s_list=[]
    my $s_hash={}
    $structs{$name}={list=>$s_list, hash=>$s_hash}
    push @struct_list, $name
    my @plist=split /,\s*/, $param;
    my $i=0
    $foreach $p in @plist
        $i++
        my $m_name="a$i"
        push @$s_list, $m_name
        $s_hash->{$m_name}={name=>$m_name, type=>$p, struct=>1}

    return $name

#---- anonymous union -----------------------
#-- $union only supported as structure member
#--     each delcare overwites previous definition
#--     to be used by nearby $struct delcaration
#--      ref: calc
fncode: declare_union_anon($param)
    $global $union_hash
    $if !$param
        # to be called from $struct
        $union_hash={}
        return $union_hash
    $elif !defined $union_hash or %$union_hash
        $call warn, "\$union has to be preceded by structure member/n"

    my @plist=split /,\s+/, $param;
    $foreach $p in @plist
        my ($type, $name)
        $if $p=~/(.*\S)\s+(\S+)\s*$/
            ($type, $name)=($1, $2)
            $if $name=~/^(\*+)(.*)/
                $type.=" $1"
                $name=$2
            $p=$name
        $else
            $name=$p;
            $type=get_c_type($p)

        $union_hash->{$name}=$type

fncode: declare_union($name, $param)
    $if $structs{$name}
        return
    $else
        my $h = declare_union_anon()
        declare_union_anon($param)
        $structs{$name}={hash=>$h, list=>undef}
        push @struct_list, $name

#-----------------------------------------
fncode: declare_struct($name, $param)
    my ($s_list, $s_hash)
    my ($s_init, $s_exit)
    $if $structs{$name}
        $s_list=$structs{$name}->{list}
        $s_hash=$structs{$name}->{hash}
        $s_init=$s_hash->{"-init"}
        $s_exit=$s_hash->{"-exit"}
    $else
        $s_init=[]
        $s_exit=[]
        $s_list=[]
        $s_hash={"-init"=>$s_init, "-exit"=>$s_exit}
        $structs{$name}={list=>$s_list, hash=>$s_hash}
        push @struct_list, $name

    $type_prefix{"st$name"}="struct $name";

    $call check_var_special, "struct($name)"
    $call declare_struct_elements

    subcode: declare_struct_elements
        my @plist=split /,\s+/, $param;
        my $i=0
        my $anon_union
        $foreach $p in @plist
            my ($m_name, $type, $needfree);
            $if $p=~/^\s*$/
                next;
            $elif $p=~/(-\w+)=>(.*)/
                #---- {-init}, {-exit}, ...
                $s_hash->{$1}=$2
                next;
            $elif $p=~/class (\w+)/
                # inheretance
                my $o=$structs{$1}
                $if $o
                    my $h=$o->{hash}
                    my $l=$o->{list}
                    $foreach $m in @$l
                        $if !$s_hash->{$m}
                            $s_hash->{$m}=$h->{$m}
                            push @$s_list, $m
                next
            $elif $p=~/^@/
                $needfree=1
                $p=$';

            $i++
            #-- init -------
            $if $p=~/(.*?)(\S+)\s*=\s*(.*)/
                $p="$1$2";
                push @$s_init, "$2=$3";

            #-- normal -----
            $if $p=~/(.*\S)\s+(\S+)\s*$/
                $type=$1;
                $m_name=$2;
                $if $m_name=~/^(\*+)(.*)/
                    $type.=" $1"
                    $m_name=$2
                $p=$m_name
            $elif $basic_types{$p} or $p=~/\*$/
                #--- anonymous member --
                $m_name="a$i"
                $type=$p
            $else
                $m_name=$p;
                $if $p=~/^(next|prev|left|right)$/
                    $type="struct $name *"
                $elif $p=~/^(u|data)$/
                    $type="union"
                $elif $fntype{$p}
                    $type="function";
                $else
                    $type=get_c_type($p);

            $if $type eq "bool"
                $page->{use_bool}=1
            #---------------------------------------- 
            $if !$s_hash->{$m_name}
                push @$s_list, $m_name
                $s_hash->{$m_name}={name=>$m_name, type=>$type, struct=>1}

            $if $needfree
                $s_hash->{"$name-needfree"}=1

            $if $type eq "union"
                $if !$anon_union
                    $anon_union = declare_union_anon()
                $s_hash->{"-union-$m_name"}=$anon_union

#- structure_autolist: 
#-     ref list_functions.def, variables.def
subcode: check_structure_autolist
    $if $structure_autolist{$1}
        my $s_list=[]
        my $s_hash={}
        $structs{$1}={list=>$s_list, hash=>$s_hash}
        push @struct_list, $1
        $if ref($structure_autolist{$1}) eq "ARRAY"
            $foreach $t in @{$structure_autolist{$1}}
                $if $t=~/^\s*(.*\S)\s+(\w+);/
                    push @$s_list, $2
                    $s_hash->{$2}={name=>$2, type=>$1, struct=>1}
        $else
            $s_hash->{"-opaque"}=1

fncode: get_struct_element($stype, $name)
    $if $stype=~/(\w+)(.*)/
        $if $typedef_hash{$1}
            $stype=$typedef_hash{$1}.$2
    $if $stype=~/struct\s+(\w+)/
        my $struc=$structs{$1};
        my $h=$struc->{hash}
        $if $h->{$name}
            return $h->{$name}
        $else
            $foreach $k in keys(%$h)
                $if $k=~/^$name\[/
                    return $h->{$k}
        $call @debug
    subcode: debug
        $if $debug eq "type"
            $while my ($k, $v)=each %$h
                print "  :|$k: $v\n"
            print "$name not defined in struct $1\n"

fncode: get_struct_element_type($stype, $name)
    my $var=get_struct_element($stype, $name)
    $if $var
        $if $var->{name} eq $name
            return $var->{type}
        $else
            my $type=$var->{type}
            $while $var->{name}=~/\[.*?\]/g
                $type .='*'
            return $type
    return "void"

fncode: struct_free
    my ($out, $ptype, $name)=@_;
    my $type=pointer_type($ptype);
    $if $type=~/struct\s+(\w+)/ and $structs{$1}
        my $s_list=$structs{$1}->{list}
        my $s_hash=$structs{$1}->{hash}
        $foreach $p in @$s_list
            $if $s_hash->{"$p-needfree"}
                struct_free($out, $s_hash->{$p}, "$name->$p")
    push @$out, "free($name);";

fncode: struct_set
    my ($struct_type, $struct_var, $val, $out)=@_;
    my $struct=$structs{$struct_type}->{list}
    my @vals=split /,\s*/, $val;
    $for $i=0:@vals
        my $sname=$struct->[$i];
        do_assignment("$struct_var\->$sname", $vals[$i], $out);

fncode: struct_get
    my ($struct_type, $struct_var, $var, $out)=@_;
    my $struct=$structs{$struct_type}->{list}
    my @vars=split /,\s*/, $var;
    for(my $i=0; $i<=$#vars; $i++){
        my $sname=$struct->[$i];
        do_assignment( $vars[$i],"$struct_var\->$sname", $out);
    }

#---------------------------------------- 
#--- ... for c++ constructor ----
fncode: get_struct_constructor($name)
    my $s_list=$structs{$name}->{list}
    my $s_hash=$structs{$name}->{hash}
    my $s_init=$s_hash->{"-init"}
    $if $s_init and @$s_init
        my @param_list
        my @initializer
        my %init_hash
        $foreach $l in @$s_init
            $if $l=~/^(\w+)=\$(\w*)/ and $s_hash->{$1}
                $(set:type=$s_hash->{$1}->{type})
                my $dummy=$2
                $if !$2
                    $dummy="dummy_$1"
                push @param_list, $(type)." $dummy"
                push @initializer, "$1=$dummy"
                $init_hash{$1}=1
            $elif $l=~/^(\w+)=(.*)/ and $s_hash->{$1}
                push @initializer, "$1=$2"
                $init_hash{$1}=1
            $else
                #- not supported
        $foreach $m in @$s_list
            $if !$init_hash{$m}
                my $default=type_default($s_hash->{$m}->{type})
                $if $default
                    push @initializer, "$m=$default"
        return (\@param_list, \@initializer)
    $else
        return (undef, undef)

#---------------------------------------- 
subcode: _autoload
    $global %basic_types
    %basic_types=(
        "int"=>1,
        "char"=>1,
        "unsigned"=>1,
        "unsigned char"=>1,
        "long"=>1,
        "float"=>1,
        "double"=>1,
    );
