include: macros_output/scope.def
macros:
    scope_return_pattern: ^(return|break|continue)
    function_need_declare: 1

#-----------------------------------------------------------------
subcode: function_param_api
    my $api_name
    $if $1
        $api_name=$2
    $elif $fname=~/^([a-zA-Z0-9]+)_(\w+)/
        $api_name=$2

    $if $fntype{$api_name}
        my $t=$fntype{$api_name}
        $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
            $func->{ret_type}=$1
            $param=$3
    $else
        die "function $fname($param): api not found\n"

#------------------------------------------------------
macros:
    function_style: c_style

subcode: function_open_c_style
    my $ret_type = $func->{ret_type}
    $if !$ret_type
        $ret_type="void"
        $func->{ret_type}=$ret_type

    my $declare=$func->{declare}
    $if !$declare
        my $param_list=$func->{"param_list"};
        my $param=join(', ', @$param_list);
        $declare="$ret_type $name($param)"
        $func->{declare}=$declare
    push @$open, $declare."{"

subcode: function_close_c_style
    push @$close, "}";
    push @$close, "NEWLINE";

#----
subcode: function_param_c_style
    my ($type, $name)
    $if $p=~/(\S.*)\s+(\S+)\s*$/
        ($type, $name)=($1, $2)
        $if $fntype{$type}
            my $t = $fntype{$type}
            $t =~s/\b$type\b/$name/
            push @$param_list, $t
            $var_hash->{$name}={name=>$name, type=>"function"}
            next
        $else
            $call check_pointer_type_name
    $elif $p eq "fmt" and $i==@plist
        push @$param_list, "const char * fmt, ..."
    $elif $p eq "..." and $i==@plist
        push @$param_list, "..."
    $else
        $if $fntype{$p}
            push @$param_list, $fntype{$p};
            $var_hash->{$p}={name=>$p, type=>"function"}
            next
        $else
            $type= get_c_type($p);
            $name=$p
    $if $name
        $if $name=~/&(\w+)/
            $name="p_$1"
            $type.=" *"
            $call set_macro, $1, "(*p_$1)"
        push @$param_list, "$type $name"

# -----------------------
subcode: infer_return_c_style
    $if $t=~/^[^(]+,/
        $cur_function->{ret_type}="void";
        $call set_return_tuple
    $else
        $cur_function->{ret_type}=infer_value_type($t)

    # -- hack return tuple --
    subcode: set_return_tuple
        my @tlist=split /,\s*/, $t
        my $param_list=$cur_function->{param_list}
        my @rlist
        my $i=0
        $foreach $t in @tlist
            $i++
            my $type=infer_value_type($t)
            push @$param_list, "$type * T$i"
            push @rlist, "*T$i = $t"
        $cur_function->{return_tuple}=$i
        push @rlist, "return"
        return join("; ", @rlist)

