include: macros_output/scope.def
macros:
    scope_return_pattern: ^(return|break|continue)
    function_need_declare: 1

#------------------------------------------------------
macros:
    function_style: c_style

subcode: function_open_c_style
    my $ret_type = $func->{ret_type}
    $if !$ret_type
        $ret_type="void"
        $func->{ret_type}=$ret_type

    my $declare=$func->{declare}
    $if !$declare
        my $param_list=$func->{"param_list"};
        my $param=join(', ', @$param_list);
        $declare="$ret_type $name($param)"
        $func->{declare}=$declare
    push @$open, $declare."{"

subcode: function_close_c_style
    push @$close, "}";
    push @$close, "NEWLINE";

#----
subcode: function_param_c_style
    my ($type, $name)
    $if $p=~/(\S.*)\s+(\S+)\s*$/
        ($type, $name)=($1, $2)
        $if $fntype{$type}
            my $t = $fntype{$type}
            $t =~s/\b$type\b/$name/
            push @$param_list, $t
            $var_hash->{$name}={name=>$name, type=>"function"}
            next
        $else
            $call check_pointer_type_name
    $elif $p eq "fmt" and $i==@plist
        push @$param_list, "const char * fmt, ..."
        next
    $elif $p eq "..." and $i==@plist
        push @$param_list, "..."
        next
    $else
        $if $fntype{$p}
            push @$param_list, $fntype{$p};
            $var_hash->{$p}={name=>$p, type=>"function"}
            next
        $else
            $type= get_c_type($p);
            $if !$type
                $call warn, Failed get_c_type: $p
            $name=$p

    $if $name
        $if $name=~/&(\w+)/
            $name="p_$1"
            $type.=" *"
            $call set_macro, $1, "(*p_$1)"
        push @$param_list, "$type $name"
        my $var={name=>$name, type=>$type}
        $if $type_class{$type}
            $var->{class}=$type_class{$type}
        $var_hash->{$name}=$var

subcode: function_param_api
    # C style api: $fntype ... defines interface
    $if $fntype{$api_name}
        my $t=$fntype{$api_name}
        $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
            $func->{ret_type}=$1
            $param=$3
    $else
        die "function $fname($param): api not found\n"

subcode: function_override
    # C++, Java style class override interface
    $if $fntype{$fname}=~/^override\s+(.*)/
        my $t=$1
        $if $t=~/^(.*?)\s*(\w+)\s*\(\s*(.*)\)/
            $func->{ret_type}=$1
            $param=$3

# -----------------------
subcode: infer_return_c_style
    $if $t=~/^[^(]+,/
        $cur_function->{ret_type}="void";
        $call set_return_tuple
    $else
        $cur_function->{ret_type}=infer_value_type($t)

    # -- hack return tuple --
    subcode: set_return_tuple
        my @tlist=split /,\s*/, $t
        my $param_list=$cur_function->{param_list}
        my @rlist
        my $i=0
        $foreach $t in @tlist
            $i++
            my $type=infer_value_type($t)
            push @$param_list, "$type * T$i"
            push @rlist, "*T$i = $t"
        $cur_function->{return_tuple}=$i
        push @rlist, "return"
        return join("; ", @rlist)

