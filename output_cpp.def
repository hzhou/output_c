include: output.def

page: output_cpp, inherit, c
    type: pm
    output_dir: lib/MyDef
    ext: cpp
    init_mode: sub
    package: MyDef::output_cpp
#---- 
subcode:: on_parsecode
    $if $l=~/^(\/\/.*)/
        push @$out, $1
        return
    $elif $l=~/^\$foreach\s+(.+?)\s+in\s+(.+)/ -> $v, $list
        $if $v=~/^\w+$/
            $v = "auto $v"
        return $(super:single_block)("for($v : $list){", "}", "foreach")
    # call other
    $elif $l=~/^(?:std::)?c(out|in|err|log)\b/
        $(super:add_include_direct)("<iostream>")

subcode: _old_parse_other
    $elif $l=~/^(\w+)\s*=\s*(\w+_)?new\s+(\w+)(.*)/ -> $v, $attr, $T, $spec
        $(super:func_add_symbol)($v, $T)
        $if $attr=~/unique|shared|weak/
            $(super:add_include_direct)("<memory>")
            push @$out, "std::${attr}ptr<$T> $v {new $T$spec};"
        $else
            push @$out, "auto $v = new $T$spec;"
        return 
#---- includes -----
subcode:: on_dumpout
    # ---- type include ----
    $foreach $type in keys %$(super:all_types)
        $if $type=~/(?:std::)?(string|bitset|deque|list|unordered_map|map|queue|set|stack|vector)\b/
            $(super:add_include_direct)("<$1>")
    # ---- include ----
    my $cnt=0
    $foreach $k in sort {$b cmp $a} (@$(super:include_list))
        $if $k=~/<(stdio|stdlib|string|math|time|errno)\.h>/
            push @$f, "#include <c$1>\n"
        $else
            push @$f, "#include $k\n"
        $cnt++
    $if $MyDef::page->{namespace}
        push @$f, "using namespace $MyDef::page->{namespace};\n"
    $if $cnt>0
        push @$f, "\n"

    @$(super:include_list)=()

#---- structs/classes -------------------------------------------------------
subcode:: on_dumpout
    my @class_dump
    $$(super:dump_classes)=\@class_dump

    $foreach $name in @$(super:struct_list)
        $call dump_struct

    @$(super:struct_list)=()

subcode: dump_struct
    push @class_dump, "struct $name {\n";
    my $s_list=$$(super:structs){$name}->{list}
    my $s_hash=$$(super:structs){$name}->{hash}
    my $i=0;
    $foreach $p in @$s_list
        $i++;
        $if $s_hash->{$p} eq "function"
            push @class_dump, "\t".$$(super:fntype){$p}.";\n";
        $else
            push @class_dump, "\t$s_hash->{$p} $p;\n";
    $call dump_struct_constructor
    push @class_dump, "};\n\n";

subcode: dump_struct_constructor
    $(if:0)
        my ($param, $init)=$(super:get_struct_constructor)($name)
        $if defined $init
            my $param_line=join(", ", @$param)
            my @init_list
            $foreach $a in @$init
                $if $a=~/(\w+)=(.*)/
                    push @init_list, "$1($2)"
            my $init_line=join(", ", @init_list)
            push @class_dump, "\t$name($param_line) : $init_line {}\n";

        my $s_exit=$s_hash->{"-exit"}
        $if $s_exit and @$s_exit
            push @class_dump, "\t~$name(){\n";
            $foreach $l in @$s_exit
                push @class_dump, "\t    $l\n";
            push @class_dump, "\t}\n";

